- Domain Driven Design (DDD)
  - Need to understand problem correctly before attempting to solve
  - Domain drive design guidelines
    - Focus on business events and workflows rather than data structures
      - Domain events: record of something that happened
        - Ex: `New order form received` -> `starts order-taking process`
        - **Event storming**: varirety of people for workshop, tons of sticky novtes, workflows triggered by events, get eeryone participating
          - Post what they know, ask questions on what they don't know, etc
          - **Really question if anything else happens before or after such order of events**
          - Benefits: Shared model of business, Awareness of teams and reporting reqs, Finds gaps in reqs, Connections between teams
      - **Commands**: request for process to happen
      - Business workflow: Series of events to event
    - Partition problem domain into smaller subdomains
      - **You must also become a bit of a domain expert**
    - Create model of each subdomain in the solution
      - Problem space -> solution space
        - Need bounded context
      - Getting context right
        - Listen to domain experts
        - Pay attention to existing team and department boundaries
        - Don't forget bounded, scope creep issue
        - design for autonomy (avoid mega-context)
        - Design for friction-free business workflow
          - even if design becomes "uglier"
      - Context maps
        - Shows bounded contexts and relationships at a high level
        - Complex designs, have series of smaller maps
      - Prioritize most important bounded context first! (Can do rest later)
        - **Core**:business advantage / brings in money?
        - **Supportive**: required but not core
        - **Generic**: not unique to business
    - Develop common language shared with everyone involved and used everywhere in project
        - Design should represent domain experts mental model
- pg 39
- Functional Architecture
  - Bounded context is autonomous with well-defined boundary
    - Initially build system as monolith then refactor later on (not important atm)
  - Communicating between bounded contexts
    - Find how contexts communicate -> mechanism of transmitting depends on architecture
  - The data needed to transfer between bounded contexts (DTOs)
    - JSON / XML / other serialization formats
  - Trust boundaries
    - validation before entering boundary
    - Do what is promised inside the bounded context
    - Remove unnecessary info leaving boundary
  - Contracts (what contexts will do to communicate with other contexts)
    - Shared kernel: shared common domain design, must collaborate
    - Customer/Supplier: downstream defines contract they want upstream context to provide
    - Conformist: downstream adapts own model to match upstream context
  - **Anticorruption layer (ACL)**
    - interface doesn't match domain, interactions and data need to be transformed into something suitable
    - Very common when using third-party component, avoid vendor locking, can use diff service later
  - Workflows
    - always within singled bounded context
    - input: data associated with command
    - output: set of events to communicate with other contexts
  - **Avoid domain events within bounded context**
    - Design to avoid hidden dependencies, deal with them as explicit events
  - Code structure
    - Traditional approach: API/Interface, Service, Domain, DB
    - Onion architecture: domain in center, other aspects around it in layers, all dependencies must point inward 
    - Hexagonal architecture
    - Clean architecture
  - Keep I/O at the edges
    - Push I/O at only start or end of workflow, not inside
- Understanding Types
  - Functions
    - Type signatures
      - Ex: `int -> int`
      - Generic, works with any type
    - Compositions (Combining things)
      - And/Product types: `FruitSald: Apple, Banana, Cherries`
      - Or/Sum types: `FruitSnack: Apple | Banana | Cherry`
  - Building domain model by composing types
    - Wrappers for primitives: `CardNumber(String cardNumber)`
    - Optional or missing values: `Option<T>: Some(T t) | None`
    - Errors: 
      - `Result<T>: Success(T t) | Error(String) | None`
      - `Either<T, U>: Success | Error`
    - Functions with no value: `Unit`
    - Collections
- Domain Modeling with Types
  - Patterns in domain model
    - Simple values / Value types: define wrapper classes over single primitive / type
      - Type safety and prevent errors at compile time
      - Memory and efficency cost, careful of domain reqs
      - **Model domain straightforward then tune and optimize**
    - Combinations: Composition of multiple types needed
    - Choices: More like a tuple / Union
    - Workflows
      - If input and output, can create Function to represent it: `payBill =  Bill -> Receipt`
      - Effects: `payBill = payBill -> Tuple<Result<Receipt>, Expection>`
        - `ValidatedReceipt = Tuple<Result<Receipt>, List<ValidationErrors>>`
  - Identity
    - Value objects: domain object without identity (names, money, dates, etc)
      - Immutability is required, not persistent, contain same data equality
    - Entities: intrinsic identity (ID) that persists as properties change
      - persistent identity, override equals and hashcode equality
      - Make copy with change of data to while preserving identity, not in issue in practice most times
    - Aggregates
      - Collection of domain objects with top level entity as root
      - Aggregate root: top level entity
      - Aggregate references
        - **Better design to store reference to entity (like the ID), not the entire entity**
- Integrity and Consistency in the Domain
  - Simple values
    - **Smart constructor** approach: private constructor, function that creates valid values and rejects invalid, returns error using `Result`
  - Invariants with type system
    - Want a list that is never empty? -> `class NonEmptyList<T> { T first; List<T> rest; }`
  - Capturing business rules in type system
    - `boolean` flag is bad design, not clear on when it should be set/unset
    - Good to have more **fine-grained types**
      ```java
      enum ContactInfo { EmailOnly, AddressOnly, EmailAndAddress }
      public class Contact { Name name; ContactInfo contactInfo; }
      ```
  - **Make illegal states unrepresentable**
    - `UnvalidatedObject { SomeType = AnUnvalidatedObjectType }`
    - `UnvalidatedObjectType -> Option<ValidatedObjectType`
  - Consistency can be avoided or delayed in most cases unless reqs demand it
    - design for eventual consistency instead of immediate consistency if possible
- Modeling Workflows as Pipelines
  - 129
- Functions
  - Higher order functions (HOFs): A function with input/output of a function
  - Currying: converting multiparameter function into single one parameter functions
    - `BiFunction<T, U, V> == Function<T, Function<U, V>>`
  - **Partial application**: some parameters already applied to the function
    - Great for dependency injection
  - Total functions: every input has an output
    - **Restrict input to eliminate illegal values**: parameters are restricted
    - **Extend the output**: return `Option` / `Result` etc
  - Composition
    - Compose functions to create a service then compose services to create workflow
    - Adjusting inputs and output to match
      - Find the **Lowest common multiple** type that satisfies both
- Composing a Pipeline
  - Simple types
    - Create function, get function
    - Can create function with types with dependencies and input
      - Use partial application to include depdenencies and remove from function parameter
    - Function adapters
    ```java
    //Example of a generic adapter, very common technique
    static <T> Function<T, T> passThroughPredicate(Function<T, Boolea predicate) {
        return input -> predicate.apply(input) ? input : throw new IllegalArgumentException("Failed predicate test");
    }
    ```
    - Using not implemented exception to sketch out implementation
    - Injecting dependencies
      - Reader monad
      - Free monad
      - 189
- 199
- 229
- 247
- 272
# Mazes

## Sources

- Mazes for Programmers by Jamis Buck

## Notes

- Common implementation

  - Array of cells
    - Each cell have walls

- **Perfect maze**
  - every cell reach every other cell by **exactly one path**
  - Have no loops or paths that interface
- **Braid maze**

  - might have loops or deadends

- Maze vs labyrinth

  - interchangable in most cases
  - Technical differences
    - Labyrinth is a single passage that never branches, always windws in convuluted path
      - **Unicursal mazes**
    - Maze has branching passages
      - **multicursal mazes**

- Texture

  - style of the passages of a maze
    - how long they tend to be
    - which direction they tend to go

- Bias

  - When signifant number of mazes generated by algorithm have same texture

- Maze representations

  - Grids
    - Cells with links
      - can precompute neighboring cells
  - Bitfield grids
    - Using integers instead of cells, each bit in int represents link to neighbor
      - Great for memory but very limited to what it can represent
  - Graphs, using edges and nodes
    - Lots of memory but can represent pretty much any maze

- Graphical display

  - Converting maze to PDF / SVG
  - Thicker walls? Good for certain mazes

- Algorithms for creating mazes

  - **Binary Tree**

    - **Very simple**
    - Requires very little memory
    - Can start anywhere
      - Essentially can have infinitely large maze
      - can generate maze in specifc area you need
    - Choose between 2 directions (north/south) and (west/east)

      - Randomly select between those 2 directions to remove wall

    - 2 major biased walls
    - **notable bias is routes tend to be diagonal**

  - **Sidewinder**
    - Similar to Binary but avoids noticable bias
    - Will create a run of cells (usually horitonzally)
      - Once randomly selected north/south to remove wall, select random cell in the run of cells to remove north/south wall
      - Clear the run and rinse and repeat
    - Only has 1 major biased walls
  - **Aldous-Broder**
    - Start anywhere in grid, choose random neighbor, move to that neighbor
      - if neighbor has no links, then link it
        - Essentially, **looking for unvisited cells**
      - Choose random neighbor to check next
    - Unbiased maze
    - Can take run for a long time as maze size increases
    - **Starts fast, ends slow**
  - **Wilsons**
    - Similar to Aldous-broder but with loop-erased random walk
      - if path that is forming intersect with itself, erase the loop before conintuing
    - Essentially, **looking for visited cells**
    - **Starts slow, ends fast**
  - **Hunt and Kill**

    - Start anywhere in grid, only choose unvisited cells
      - If all visited, iterate through all visited and find any unvisited cells to start process again
    - Paths tend to wind aorund a lot

  - **Recursive backtracking / Depth First Search**
    - faster than hunt and kill but requires more memory
    - Maintain stack of visited nodes, only pop if no unlinked neighbors
    - Similar maze as hunt and kill

- Masking mazes
  - Great for creating ASCII mazes or even creating areas that can't be accessed
    - Can create shapes
  - Can generate mazes from Strings / Files / Images
  - Uses masking grid (boolean)
    - Not all algoritihms can handle masking
    - **Can use multi-state masks**, great for splitting maze up into multiple sections to do different styles
- Creating perfect circle mazes

  - Need to convert regular/orthogonal grid into **polar grid coordinates** when drawing
    - theta, inner radius, outer radius, theta ccw, theta cw
  - Need levels instead of rows/columns
  - Need **Adapative subdivision** for better evenly sized cells
    - forwards, inward, cw, ccw cells
  - pg 115

- Braiding and Weaving mazes

  - No longer a perfect maze

  - Braiding
    - removing dead ends to add loops to mazes
    - **Braid maze: has no dead ends**
      - Dead-end culling to produce any level of braiding
  - Weaving mazes

    - allow passages to intersect by moving over and under each other

    - **Trick is how to represent passages that tunnel undeath others**

      - 4 rules
        - passage cannot dead-end over or under another passage
        - over and under passages must be perpendicular to each other
        - Passages may not change direction while above or below other passages
        - Passage may not tunnel under 2 consecutive passages at once
          - Just makes things easier to implement
      - On-demand creationg

        - under-cell cannot be unear another under-cell (harder to draw if this happens)

        - Tunnel under call if actually another cell on other side of vertical/horizontal passage

  - Spark mazes
    - Remove dead end completely from the map
      - can repeat this process until satisfied
  - Obstacles in paths

- Metrics on mazes

## Questions

- Questions (Binary Tree)
  - How might one reorient the paths?
  - How to make bias more vertical or more horizontal?
- Questions (Sidewinder)
  - How might one reorient the paths?
  - How to make longer horizontal runs or longer vertical runs?
- Questions (Hunt and Kill)
  - other ways to hunt for cells?
  - How to make passages stretch horizontally?
- Questions (Recursive backtracking)
  - Try making a recursive recursive version
- Questions
  - How might you remove dead-ends? What effects would it have?
  - Weaving, some algorithms will need to tuned to handle weaving logic

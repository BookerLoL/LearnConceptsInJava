# Mazes

## Sources (Code and Information from these sources)

- Mazes for Programmers by Jamis Buck
  - Most of the code and notes are from his book
- https://www.astrolog.org/labyrnth/algrithm.htm
- https://www.reddit.com/r/mazes/
- https://en.wikipedia.org/wiki/Maze_generation_algorithm
- https://github.com/armin-reichert/mazes/tree/master/mazes-algorithms/src/main/java/de/amr/maze/alg
- https://github.com/jamis/csmazes/blob/master/src/algorithms/houston.coffee

## Notes

- Common implementation

  - Array of cells
    - Each cell have walls

- **Perfect maze**
  - every cell reach every other cell by **exactly one path**
  - Have no loops or paths that interface
- **Braid maze**

  - might have loops or deadends

- Maze vs labyrinth

  - interchangable in most cases
  - Technical differences
    - Labyrinth is a single passage that never branches, always windws in convuluted path
      - **Unicursal mazes**
    - Maze has branching passages
      - **multicursal mazes**

- Texture

  - style of the passages of a maze
    - how long they tend to be
    - which direction they tend to go

- Bias

  - When signifant number of mazes generated by algorithm have same texture

- Maze representations

  - Grids
    - Cells with links
      - can precompute neighboring cells
  - Bitfield grids
    - Using integers instead of cells, each bit in int represents link to neighbor
      - Great for memory but very limited to what it can represent
  - Graphs, using edges and nodes
    - Lots of memory but can represent pretty much any maze

- Graphical display

  - Converting maze to PDF / SVG
  - Thicker walls? Good for certain mazes

- Algorithms for creating mazes

  - **Binary Tree**

    - **Very simple**
    - Requires very little memory
    - Can start anywhere
      - Essentially can have infinitely large maze
      - can generate maze in specifc area you need
    - Choose between 2 directions (north/south) and (west/east)

      - Randomly select between those 2 directions to remove wall

    - 2 major biased walls
    - **notable bias is routes tend to be diagonal**

  - **Sidewinder**
    - Similar to Binary but avoids noticable bias
    - Will create a run of cells (usually horitonzally)
      - Once randomly selected north/south to remove wall, select random cell in the run of cells to remove north/south wall
      - Clear the run and rinse and repeat
    - Only has 1 major biased walls
  - **Aldous-Broder**
    - Start anywhere in grid, choose random neighbor, move to that neighbor
      - if neighbor has no links, then link it
        - Essentially, **looking for unvisited cells**
      - Choose random neighbor to check next
    - Unbiased maze
    - Can take run for a long time as maze size increases
    - **Starts fast, ends slow**
  - **Wilsons**
    - Similar to Aldous-broder but with loop-erased random walk
      - if path that is forming intersect with itself, erase the loop before conintuing
    - Essentially, **looking for visited cells**
    - **Starts slow, ends fast**
  - **Hunt and Kill**

    - Start anywhere in grid, only choose unvisited cells
      - If all visited, iterate through all visited and find any unvisited cells to start process again
    - Paths tend to wind aorund a lot

  - **Recursive backtracking / Depth First Search**
    - faster than hunt and kill but requires more memory
    - Maintain stack of visited nodes, only pop if no unlinked neighbors
    - Similar maze as hunt and kill
  - **Randomized Kruskals**
    - Despite being a graph algorithm, can randomly generate pairs / create custom pairs to supply
    - Very useful if you want more crosses in weaved mazes
  - **Simplified Prims**
    - Similar to growing tree, selects random cell from active list
  - **Prims**
    - Gives random weights to all cells, sort them on priority queue, process each cell until empty queue
  - **Growing Tree**
    - Essentially a generalized approach that other algorithms tend to do
      - The differece is hwo it choose which cell to process in the active list of cells to process
  - **Ellers**
    - Essentially a mix of sidewinder and kruskals algorithm
  - **Recursive division**
    - Wall adder algorithm
    - Start with empty grid
    - divide the board horizontally & vertically until width/height less than or equal to 1
      - Every division, add a wall to all the cells except for 1
      - repeat subdividing horizontally & vertically until reaching base case
  - Other algorithms
    - Cellular automata, good with bitmasking but may not create a complete maze

- Masking mazes
  - Great for creating ASCII mazes or even creating areas that can't be accessed
    - Can create shapes
  - Can generate mazes from Strings / Files / Images
  - Uses masking grid (boolean)
    - Not all algoritihms can handle masking
    - **Can use multi-state masks**, great for splitting maze up into multiple sections to do different styles
- Creating perfect circle mazes

  - Need to convert regular/orthogonal grid into **polar grid coordinates** when drawing
    - theta, inner radius, outer radius, theta ccw, theta cw
  - Need levels instead of rows/columns
  - Need **Adapative subdivision** for better evenly sized cells
    - forwards, inward, cw, ccw cells
  - pg 115

- Braiding and Weaving mazes

  - No longer a perfect maze

  - Braiding
    - removing dead ends to add loops to mazes
    - **Braid maze: has no dead ends**
      - Dead-end culling to produce any level of braiding
  - Weaving mazes

    - allow passages to intersect by moving over and under each other

    - **Trick is how to represent passages that tunnel undeath others**

      - 4 rules
        - passage cannot dead-end over or under another passage
        - over and under passages must be perpendicular to each other
        - Passages may not change direction while above or below other passages
        - Passage may not tunnel under 2 consecutive passages at once
          - Just makes things easier to implement
      - On-demand creationg

        - under-cell cannot be unear another under-cell (harder to draw if this happens)

        - Tunnel under call if actually another cell on other side of vertical/horizontal passage

  - Spark mazes
    - Remove dead end completely from the map
      - can repeat this process until satisfied
  - Obstacles in paths

- Templates

  - shapes inside mazes: zig-zags, spirals, open rooms, and other types of corridors
    - This can easily by set up by kruskals algorithm by preconfiguring certain styles
      - Aldous-broder, recursive backtracker can be adpated to support templates

- Multidimensional Mazes
  - Can mimic dungeons, time traveling, portal jumping, office blocks, cave systems, etc
  - Can't add multiple ladders between 2 floors, results in loops
  - 3D mazes: rows, columns, levels
    - 3D cell with level, up, and down fields
    - Need to modify methods a bit to handle extra logic of levels
      - Some algorithms may need a slight fix
        - Kruskal, Binary Tree, Sidewinder, etc
  - 4D mazes: grids, levels, rows, columns
    - hither/yon dimension
- Bending and Folding mazes

  - Planair mazes
    - Cylinders, cubes, cones, pyramids, spheres, etc
  - Cylinder mazes
    - Print out rectangular mazes, wrap around cylinder object
  - Moebius strip mazes
    - Essentially double the maze columns and find mid point then print with inset
  - Cube mazes
    - Create cube cell with Face and cube grid with 6 Faces attribute
    - Will need a wrap function to determine the correct face
  - Sphere mazes
    - Hemistphere grid and cell (hemisphere)

## Questions

- Questions (Binary Tree)
  - How might one reorient the paths?
  - How to make bias more vertical or more horizontal?
- Questions (Sidewinder)
  - How might one reorient the paths?
  - How to make longer horizontal runs or longer vertical runs?
- Questions (Hunt and Kill)
  - other ways to hunt for cells?
  - How to make passages stretch horizontally?
- Questions (Recursive backtracking)
  - Try making a recursive recursive version
- Questions
  - How might you remove dead-ends? What effects would it have?
  - Weaving, some algorithms will need to tuned to handle weaving logic
  - Insets for hex/triangle/polar grids?
  - How to create super dense weaves?
- Questions
  - How to change neighbor selection critera for kruskals algorithm twith visually obvious textures?
- Questions
  - How to make ellers algorithm arbitrarily infinite if never given last row?
  - How to make Ellers algorithm work with hexes and circle grid?
  - Irregular divisions, how to divide to have non-rectangular regions?
  - How to run other algorithms inside the empty rooms in recursive division
  - Which algorithms could you make it being a wall adder / passage carvers (some can be both but may not perform well in some cases)
- Questions
  - How to support different types of stacked grids?
  - Forcing level bias, prefer cells on smae floor over up/down
  - Polyhedra, rhombic doecahedrons, might want to use first person perspective to visual maze
- Questions
  - Rendering cylinder mazes
    - Consider using POV-ray for rendering
  - Rectangular prisms?
  - Cone mazes?
  - How to add real walls to mazes?
  - Rendering 4D mazes onto objects: Tesseracts, duo-cylinders, glomes

## Implementation Examples

```java
public static void recursiveBacktrackerMaze(Grid grid) {
    Cell cell = start;
    Stack<Cell> stack = new Stack<>();
    stack.add(cell);

    while (!stack.isEmpty()) {
        cell = stack.peek();

        Optional<Cell> unvisitedCell = random(cell.neighborsWithoutLinks());
        if (unvisitedCell.isPresent()) {
            Cell next = unvisitedCell.get();
            cell.link(next);
            stack.add(next);
        } else {
            stack.pop();
        }
    }
}
```
